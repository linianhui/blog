---
title: '[漫谈] 软件设计的目标和途径'
created_at: 2020-07-30 18:08:01
tag: ["软件设计","目标","途径","失控","可维护性"]
toc: true
---

记录一下笔者关于软件设计的一些相关认知。在开始之前，先引入两个概念`目标`和`途径`(这里可能会有些咬文嚼字，不过主要是为了区分主观和客观的一些细微差异)。

# 1 目标和途径 {#concept-objective-and-approach}

我们在做某一件事情的时候，总是会带有一定的目的性的：比如说一日三餐，是为了给身体补充所需的能量。那么这三餐具体如何落实呢，则会有多种多样的方式。比如你可以选择吃碳水食物、蔬菜、肉类、牛奶或者蛋类等等；也可以选择通过静脉注射一些所需的葡萄糖或者蛋白质。总之，能够为身体补充能量就可以了。

## 1.1 目标 {#concept-objective}

那么在上述的小例子中，我们的`目的`就是给身体补充能量，用以维持正常的生命活动所需。当然也可以说是我们的`目标`，不过`目标`侧重于过程，目的则更强调结果。

## 1.2 途径 {#concept-approach}

从上面的例子中可以看出有多种方式可以达成我们的上述`目的`。其中每一种方式都是一条达成`目的`的`途径`，当然我们为了补充均衡的能量，通常会搭配组合几种不同的食物，我把这个称之为手段或者方法。`手段`和`方法`带有一定的主观性；而`途径`则是在描述客观的可供选择的一种方式。

# 2 软件的目的 {#goal-of-software}

在开始讨论软件设计之前先问自己一个最基本的问题：我们为什么需要软件？

笔者认为是为了解决现实中某个领域的相关问题而存在的。就好比最初的计算机是用来计算导弹的弹道的。生活中常用的QQ和微信是为了满足人们的社交通信需求的，淘宝京东等是满足了人们的买买买的需求。

**所以，软件存在的目的就是它能解决一些领域的相关问题，这是它存在的唯一理由**。
> 比如在黑客帝国这部电影中，不再被使用的程序只有一个下场，那就是被删除掉。

# 3 软件设计的目标 {#objective-of-software-design}

假如一开始就有了软件，其实要不要软件设计都不重要了。但是问题在于软件不是凭空产生的，不是从0到1没有中间过程就直接得到了想要的软件的。**在软件从0到1的过程，就是软件设计的作用范围（所以在这里我用软件设计的目标这个概念）**。因为软件存在的目的在于它能解决一些领域的相关问题，那么首先对软件的最低要求就是它能用，能用来解决问题。比如一个数学上的加减乘除计算器，最低最低的要求是你要能把结果算对吧。所以软件设计的目标是什么？笔者认为就是控制这个从0到1的过程，避免其失控（一旦失控你可能就连最低最低的软件的要求都达不到了）。

>[《领域驱动设计：软件核心复杂性应对之道》](https://book.douban.com/subject/5344973/)一书的副标题也是这个含义。它的侧重点在于如何利用面向对象的方式应对软件本身的复杂性，从而避免其失控。

**那么笔者对软件设计的目标的认知就是：避免软件的失控。为什么是目标而不是目的呢？是因为软件设计在软件的整个生命周期中都是存在着的，这是一个持续的过程，直到软件不再被使用的那一天；而非只在刚开始设计一下，后续就一成不变了**。


# 4 失控的根本原因 {#the-root-cause-of-losing-control}

上面推导出软件设计的目标是**避免软件的失控**。那么是什么东西导致的**失控**? 你面临的业务太复杂？项目遗留的代码太烂？团队成员水平参差不齐？工期太紧张导致你无暇做设计规划？也许吧，这些或多或少都确实是已经存在的事实。

1. 业务太复杂难道是失控的原因吗？回想一下**软件的目的**是什么？**解决一些领域的相关问题**，那么我们可以让业务的复杂性会消失或者降低吗？答案是肯定的，**不会**！这里就有人要说你放屁。。。你敢说我们无法降低业务复杂性，打你噢。你就是打死我复杂性也不会降低的，，，**复杂性是业务本身存在的客观属性，是不会以人的意志来改变的，除非你不做它了**。就像你现在要在淘宝买一个手机，你人在北京，卖方在广州，无论你用什么快递方式，从广州到北京这段物理距离上的时间消耗是无法消除的。你说你比较着急，那好，卖方给你选择空运，很快你就收到货了。你说空运这不是降低了快递时间，和降低复杂性不是一样的吗？ 其实并不是，因为复杂性指的是**无论你用什么快递方式，从广州到北京这段物理距离上的时间消耗是无法消除的**，指的是这个过程你无法消除。但是总觉得怪怪的对吗？是的，看起来是怪怪的，明明我收到货的时间缩短了，怎么复杂性没有改变呢？所以这里就引申出另外一个概念：**业务交互方式所带来的影响**。这个影响非常之大，但是往往被我们所忽略，比如你选择购买发货地是北京的卖方了，是不是时间又进一步大大缩短了？**实际业务上也是这样的，业务本身具备的复杂性，以及我们在把业务转化为软件后的交互方式所带来的影响，业务本身的复杂性我们无法降低和消除，但是后者交互方式则是可以控制的，这也是软件设计的一部分，所以其实上面我们选择空运是改变了这部分**。就好比你是一个B/S的应用软件，你的用户在浏览器中看到了Web页面。这背后你的Web页面从服务器到用户浏览器的过程和浏览器渲染页面的过程是无论如何也无法消除的，但是浏览器可以缓存它，当你下次再打开这个页面时，它就可以省掉上述的交互过程。
2. 项目遗留的代码太烂是失控的原因吗？其实也不是，这是失控的一种表现结果。
3. 团队成员水平参差不齐是失控的原因吗？也不是，这虽然是客观存在的事实，但是你这样把责任推到队友身上不合适吧，说不定队友也是这么看你的呢。
4. 工期太紧张导致你无暇做设计规划是失控的原因吗? 当然也不是，这个是借口。。。就像你今天起床快要迟到了，你会选择光屁股不穿衣服就出门吗？

除了上述的一些事实，当然还有其他的一些因素，**看起来都不像是导致失控的罪魁祸首**。那么究竟是什么导致的失控？？？仔细回想一下，当我们觉得项目失控的时候通常是什么场景？

1. 有个已知的bug，你改动的时候发现牵扯的东西太多了，牵一发而动全身，你不敢下手。你觉得代码无法控制了。。。
2. 有个未知的bug，你找了好久找不到，代码太乱了。你觉得一股无力感。。。
3. 有个新功能来了，你发现你要改这里那里，但是完全不知道改了会不会破坏现有的功能，也不知道新功能是不是真的可以work。你觉得你无法掌控这些代码了。。。
4. 还有一些其他的情况，总之就是你觉得你无法掌控代码的真实行为了，你不知道你的代码会产生什么样的结果，就像薛定谔的代码一样。。。

那么还有一个场景，当你要开展一个新的项目，所有的一切都是新的，没有任何历史债务负担，这时候你是什么感觉？信心满满啊肯定是，这时候你不会觉得你会对接下来的代码失去控制，因为你现在一行代码都还没有。。。

所以是什么导致的失控？**现存的无力维护(bug、新功能都是维护)的代码导致的失控**，同时这也是失控的表现结果。那么你为什么会**无力维护**这些代码，因为它的真实行为和你理解的行为出现了偏差，你觉得它不可控了。这时候就是真的失控了，代码烂不烂其实并不是重点，只要你还能维护，这些都不是问题。

> 代码只会按照你编写的行为去执行，而不是按照你认为的行为去执行。

那么如何避免失控？**编写可维护的代码**。打死你噢，解释这么半天憋出这么一句废话，谁不知道要编写可维护的代码啊。。。

我只能说别着急，继续慢慢往下看。。。

# 5 目标-可维护性 {#objective-maintainability}

既然我们的目标是避免失控，避免失控的途径则是**编写可维护的代码**。那么我就把**可维护性**作为软件设计的终极目标，而且没有之一。也称之为**元原则**，就是说我们目前所接触到的各自编程原则、建议和最佳实践等等都可以通过**可维护性**推导细化出来，并且不可与之相违背。

> 打个比喻，就好比宪法是其他一切法律的基础，任何法律如果违背了宪法，那么就是无效的。

那么根据**可维护性**可推导出来3个核心的原则：**可理解性**、**可测试性**和**可隔离性**。

## 5.1 可理解性 {#objective-intelligibility}

这条原则看起来很有主观性的倾向，但是其实并不是。

比如说你刚写了一段代码，你觉得容易理解，他看起不容易理解；或者说代码是他写的，他看起来很容易理解，但是到你这里无法一下子理解他的思维，然后你就觉得不好理解。**如果出现了这样的情况，那么则统统都是不可理解的**。这时候你要说了：你要一棍子打死双方啊。是的，正是如此。再回想一下我们的目标是什么？**可维护性！** 这里的维护不单单是说你的代码你来维护，而是大家互相交叉着；你新增了一个功能，后续负责其他的事情去了，那么这时候就由你的队友来负责维护了；或者你接手维护别人的代码。

所以我们需要一个客观上的**可理解性**。那么到底什么才能叫客观？没法度量啊！其实也不复杂，就是看当你读到一段代码的时候，你是否需要额外的思考，额外的脑中维持一个上下文的环境才能明白这段代码的意图，如果需要，那么就是不可理解的，至少也是不易理解的。**更简单点说就是这段代码应该让你不用思考就看的明白它的意图**。比如下面的一个小例子，功能是完全等价的，但是差异非常微妙。

```js
// 1
if(userList.isNotEmpty()){

}

// 2
if(userList.isEmpty() == false){

}

// 3
if(!userList.isEmpty()){

}

// 4
if(userList.length() != 0){

}
```

你觉得可理解性怎么排？ 答案是肯定的吧？`1 > 2 > 3 > 4`。

1. 1是不是你根本就不用思考，直接读下来就知道其含义？
2. 2则是有一个`==fasle`的过程，需要你进行简单的思考。
3. 3则是接近于2，但是比2更差一点，因为取反符号在前面，但是其决定性的值则在后面，而你的阅读顺序是从左向右，所以你需要一个比2稍微更复杂一点的思考过程。
4. 前三个还都一眼能看出来是**空**或者**非空**的语境，但是4就更差了，4的字面意思是长度不等于0，逻辑上其实和**非空**是等价的，但是你需要在脑中做这样的一个映射**长度!=0**等同于**非空**，这个的抽象层级明显更低了一个层级。

不知道能否体会其中差细微差异。那么你觉得这些理解是客观的还是主观的呢?

## 5.2 可测试性 {#objective-testability}

可理解性可以确保你可以快速的理解现存代码的意图，但是其真实的行为呢？是不是和你所认为的行为就是一致的？上面我说过：“**代码只会按照你编写的行为去执行，而不是按照你认为的行为去执行**”。

那么如何确保你真实的行为和你所认为的行为是一致的？那就是**测试**。把你认为的行为也写成代码，去验证你的业务代码执行的时候是不是会按照你给定的输入得到你期望的输出结果。借助自动化的CI，就可以在你每次改动代码时把现有的所有测试都运行一遍，然后你至少可以获得3点收益：

1. 代码真的时按照你认为的行为去执行的。
2. 确保你的改动不会破坏现有的代码行为。
3. 倒逼你的代码进行合理的分解和抽象，不然你很难编写有效的测试。

当然你可能把测试写错了，，，这种概率就小多了吧。况且假设你真的写错了测试，时间久了，这个错误也就变成了**feature**。为什么呢？也许你代码的消费方已经按照它实际的行为去处理了，这时候你贸然把这个bug修复了，结果可能时消费方反而不能正常工作了。这时候这个错误的测试其实也就变成了消费方的一种契约测试。确保你不会把它改对，，，

> 比如C#的类库中有个`DateTime`，在处理时区问题时很多诡异的行为，这时候微软已经无法修正它了，只好再单独新增了一个`DateTimeOffset`，两者共存，慢慢的迁移过去。

## 5.3 可隔离性 {#objective-isolability}

那么现在你可以快速的理解现存的代码了，也可以确保你的新代码不会破坏已有的功能，也确认你的代码行为是你所认为的行为了。是不是就可以愉快的合并代码并且上线发布了？是的，差不多可以了。但是，凡是总有例外，我们不能把全部希望都寄托在我们能严格落实上述两点。总是要有个备选方案对吧？

可隔离性就是这样的一个备选方案，其意图就是隔离你的代码行为，哪怕它就是腐烂变质成了不可维护的代码，只要不影响其他的模块，那么就还算是可控的。就像万吨巨轮，底层的隔水舱总是一个个的独立的，一个进水了也不影响其他的，从而避免整体的失控。

# 6 途径 {#approach}

还记得文章开始介绍的**目标**和**途径**的概念吧，上述的3个原则是我们的目标，那么想要达成这样的目标有哪些途径可供使用呢？

## 6.1 数据模型匹配 {#data-model-matching}

数据模型匹配的含义是说让你的代码真实的表达实际的业务意图，而且这个意图必须要落实到数据层面，而非代码层面。感觉有点绕噢，什么鬼意思？

| 目标     | 效果 | 解释                                                                                           |
| :------- | :--- | :--------------------------------------------------------------------------------------------- |
| 可理解性 | ++   | 匹配的模型可以表达真实的业务意图，没有中间转换的环节，可以让你再理解代码时没有额外的心智负担。 |
| 可测试性 | +    | 使得测试更能直观的描述真实的业务行为。                                                         |
| 可隔离性 | +    |                                                                                                |

## 6.2 单一职责 {#single-responsibility}

| 目标     | 效果 | 解释 |
| :------- | :--- | :--- |
| 可理解性 | ++   |      |
| 可测试性 | ++   |      |
| 可隔离性 | ++   |      |

## 6.3 抽象层级 {#abstract-level}

| 目标     | 效果 | 解释 |
| :------- | :--- | :--- |
| 可理解性 | ++   |      |
| 可测试性 | ++   |      |
| 可隔离性 | ++   |      |

## 6.4 奥卡姆剃刀 {#occam-razor}

| 目标     | 效果 | 解释 |
| :------- | :--- | :--- |
| 可理解性 | +    |      |
| 可测试性 | +    |      |
| 可隔离性 | +    |      |

# 7 一些误区 {#pitfalls}

看到这里估计有人要忍不住要批判我了：

1. 可复用性呢？GoF23种设计模式都强调构建可复用性的软件，可复用性跑哪去了？被你吃了啊。
2. 可靠性呢？健壮性呢？
3. 高可用性呢？

等等吧，就像当年软工课程上罗列的各种指标。其实不是说这些东西不重要，或者我不认可这些东西，我认可，也理解它们的重要性。**但是有一点要彻底搞清楚，哪些是我们的目标？哪些是我们的途径？** 就拿可复用性来说吧，这难道是我们追求的目标吗？我的回答是：肯定不是啊，我们的目标是软件的可维护性。那么你说复用就会增加可维护性，其实不尽然，不合适的复用反而会降低可维护性，这是一把双刃剑，借用著哥的一句话：“越通用越无用”。那么你说不是目标也是途径吧！那么我的回答是：也不是途径，你这条途径可能会违宪，你觉得它合适吗？也不是目标，也不是途径，那么它到底是什么？答：是一种现象，如果你落实了上述的4种途径某些途径，你会发现你的代码自然而然的就可以复用了。

待补充...