---
title: '[漫谈] 软件设计的目标和途径'
created_at: 2020-07-30 18:08:01
tag: ["软件设计","目标","途径","失控","可维护性"]
toc: true
---

记录一下笔者关于软件设计的一些相关认知。在开始之前，先引入两个概念`目标`和`途径`(这里可能会有些咬文嚼字，不过主要是为了区分主观和客观的一些细微差异)。

# 1 目标和途径 {#objective-and-approach}

我们在做某一件事情的时候，总是会带有一定的目的性的：比如说一日三餐，是为了给身体补充所需的能量。那么这三餐具体如何落实呢，则会有多种多样的方式。比如你可以选择吃碳水食物、蔬菜、肉类、牛奶或者蛋类等等；也可以选择通过静脉注射一些所需的葡萄糖或者蛋白质。总之，能够为身体补充能量就可以了。

## 1.1 目标 {#objective}

那么在上述的小例子中，我们的`目的`就是给身体补充能量，用以维持正常的生命活动所需。当然也可以说是我们的`目标`，不过`目标`侧重于过程，目的则更强调结果。

## 1.2 途径 {#approach}

从上面的例子中可以看出有多种方式可以达成我们的上述`目的`。其中每一种方式都是一条达成`目的`的`途径`，当然我们为了补充均衡的能量，通常会搭配组合几种不同的食物，我把这个称之为手段或者方法。`手段`和`方法`带有一定的主观性；而`途径`则是在描述客观的可供选择的一种方式。

# 2 软件的目的 {#goal-of-software}

在开始讨论软件设计之前先问自己一个最基本的问题：我们为什么需要软件？

笔者认为是为了解决现实中某个领域的相关问题而存在的。就好比最初的计算机是用来计算导弹的弹道的。生活中常用的QQ和微信是为了满足人们的社交通信需求的，淘宝京东等是满足了人们的买买买的需求。

**所以，软件存在的目的就是它能解决一些领域的相关问题，这是它存在的唯一理由**。
> 比如在黑客帝国这部电影中，不再被使用的程序只有一个下场，那就是被删除掉。

# 3 软件设计的目标 {#objective-of-software-design}

假如一开始就有了软件，其实要不要软件设计都不重要了。但是问题在于软件不是凭空产生的，不是从0到1没有中间过程就直接得到了想要的软件的。**在软件从0到1的过程，就是软件设计的作用范围（所以在这里我用软件设计的目标这个概念）**。因为软件存在的目的在于它能解决一些领域的相关问题，那么首先对软件的最低要求就是它能用，能用来解决问题。比如一个数学上的加减乘除计算器，最低最低的要求是你要能把结果算对吧。所以软件设计的目标是什么？笔者认为就是控制这个从0到1的过程，避免其失控（一旦失控你可能就连最低最低的软件的要求都达不到了）。

>[《领域驱动设计：软件核心复杂性应对之道》](https://book.douban.com/subject/5344973/)一书的副标题也是这个含义。它的侧重点在于如何利用面向对象的方式应对软件本身的复杂性，从而避免其失控。

**那么笔者对软件设计的目标的认知就是：避免软件的失控。为什么是目标而不是目的呢？是因为软件设计在软件的整个生命周期中都是存在着的，这是一个持续的过程，直到软件不再被使用的那一天；而非只在刚开始设计一下，后续就一成不变了**。


# 4 失控的根本原因 {#the-root-cause-of-losing-control}

上面推导出软件设计的目标是**避免软件的失控**。那么是什么东西导致的**失控**? 你面临的业务太复杂？项目遗留的代码太烂？团队成员水平参差不齐？工期太紧张导致你无暇做设计规划？也许吧，这些或多或少都确实是已经存在的事实。

1. 业务太复杂难道是失控的原因吗？回想一下**软件的目的**是什么？**解决一些领域的相关问题**，那么我们可以让业务的复杂性会消失或者降低吗？答案是肯定的，**不会**！这里就有人要说你放屁。。。你敢说我们无法降低业务复杂性，打你噢。你就是打死我复杂性也不会降低的，，，**复杂性是业务本身存在的客观属性，是不会以人的意志来改变的，除非你不做它了**。就像你现在要在淘宝买一个手机，你人在北京，卖方在广州，无论你用什么快递方式，从广州到北京这段物理距离上的时间消耗是无法消除的。你说你比较着急，那好，卖方给你选择空运，很快你就收到货了。你说空运这不是降低了快递时间，和降低复杂性不是一样的吗？ 其实并不是，因为复杂性指的是**无论你用什么快递方式，从广州到北京这段物理距离上的时间消耗是无法消除的**，指的是这个过程你无法消除。但是总觉得怪怪的对吗？是的，看起来是怪怪的，明明我收到货的时间缩短了，怎么复杂性没有改变呢？所以这里就引申出另外一个概念：**业务交互方式所带来的影响**。这个影响非常之大，但是往往被我们所忽略，比如你选择购买发货地是北京的卖方了，是不是时间又进一步大大缩短了？**实际业务上也是这样的，业务本身具备的复杂性，以及我们在把业务转化为软件后的交互方式所带来的影响，业务本身的复杂性我们无法降低和消除，但是后者交互方式则是可以控制的，这也是软件设计的一部分，所以其实上面我们选择空运是改变了这部分**。就好比你是一个B/S的应用软件，你的用户在浏览器中看到了Web页面。这背后你的Web页面从服务器到用户浏览器的过程和浏览器渲染页面的过程是无论如何也无法消除的，但是浏览器可以缓存它，当你下次再打开这个页面时，它就可以省掉上述的交互过程。
2. 项目遗留的代码太烂是失控的原因吗？其实也不是，这是失控的一种表现结果。
3. 团队成员水平参差不齐是失控的原因吗？也不是，这虽然是客观存在的事实，但是你这样把责任推到队友身上不合适吧，说不定队友也是这么看你的呢。
4. 工期太紧张导致你无暇做设计规划是失控的原因吗? 当然也不是，这个是借口。。。就像你今天起床快要迟到了，你会选择光屁股不穿衣服就出门吗？

除了上述的一些事实，当然还有其他的一些因素，**看起来都不像是导致失控的罪魁祸首**。那么究竟是什么导致的失控？？？仔细回想一下，当我们觉得项目失控的时候通常是什么场景？

1. 有个已知的bug，你改动的时候发现牵扯的东西太多了，牵一发而动全身，你不敢下手。你觉得代码无法控制了。。。
2. 有个未知的bug，你找了好久找不到，代码太乱了。你觉得一股无力感。。。
3. 有个新功能来了，你发现你要改这里那里，但是完全不知道改了会不会破坏现有的功能，也不知道新功能是不是真的可以work。你觉得你无法掌控这些代码了。。。
4. 还有一些其他的情况，总之就是你觉得你无法掌控代码的真实行为了，你不知道你的代码会产生什么样的结果，就像薛定谔的代码一样。。。

那么还有一个场景，当你要开展一个新的项目，所有的一切都是新的，没有任何历史债务负担，这时候你是什么感觉？信心满满啊肯定是，这时候你不会觉得你会对接下来的代码失去控制，因为你现在一行代码都还没有。。。

所以是什么导致的失控？**现存的无力维护(bug、新功能都是维护)的代码导致的失控**，同时这也是失控的表现结果。那么你为什么会**无力维护**这些代码，因为它的真实行为和你理解的行为出现了偏差，你觉得它不可控了。这时候就是真的失控了，代码烂不烂其实并不是重点，只要你还能维护，这些都不是问题。

> 代码只会按照你编写的行为去执行，而不是按照你认为的行为去执行。

那么如何避免失控？**编写可维护的代码**。打死你噢，解释这么半天憋出这么一句废话，谁不知道要编写可维护的代码啊。。。

我只能说别着急，继续慢慢往下看。。。

# 5 一些误区 {#pitfalls}

如果你认同笔者上述的观点。那么我们就可以鉴别出来如今关于软件设计中的一些原则也好，一些方法论也好，等等。其中有不少大家习以为常的观点可能就有些本末倒置了。

待补充...